# Assignment III : 鏈結串列與選擇排序法 (Linked List Selection Sort)


### 一、 作業目的與說明

- 本次作業的核心目標是學習如何使用**鏈結串列 (Linked List)** 來儲存資料，並在其上實作**選擇排序法 (Selection Sort)**。

- 透過實作深入探討鏈結串列 (Linked List) 與陣列 (Array) 的差異，特別是記憶體配置（連續 vs. 非連續）、元素存取效率（隨機存取 vs. 循序遍歷）以及空間開銷 (Overhead) 等方面的權衡。


### 二、 實作內容

針對數列 `60, 24, 15, 42, 20, 11, 90, 8`，完成了以下任務：

1.  **鏈結串列視覺化 (A1 & A2)**：
   
    * 繪製單一節點結構（包含值 `Value` 與指標 `Next`）。
      
    * 建立包含 8 個節點的串列，正確標註 `Head` 指標與 `Tail` 指標。
      > **訂正**：在繪製鏈結串列末端時，**不該僅使用「接地符號」表示終點**，應繪製指標指向 `NULL`，並特別**標示 tail 指標**，以確保結構標記的完整性與嚴謹性。
  
2.  **選擇排序法步驟追蹤 (A3)**：
   
    * 本作業採用「**交換節點值 (Value Swapping)**」而非修改指標連結的方式完成排序。
   
    * **Step 1 (i=60)**：遍歷全串列找到最小值 **8**，與起始位置 60 交換值。

    * **Step 2 (i=24)**：從第二個節點開始找到最小值 **11**，與 24 交換值。
      
    * **Step 3 (i=15)**：掃描發現最小值即為當前位置的 **15**。
      > **自我交換 (Self-Swap) 判定**：在 Step 3 追蹤時，最小值剛好就是當前節點 (15)，因此在「是否調用交換函數」處應勾選 **No**，以減少多餘操作。
      
    * **Step 4 (i=42)**：找到最小值 **20**，與 42 交換值。
      
3.  **比較討論 (A4)**：完整分析並填寫陣列與鏈結串列在存取、搜尋、交換與空間複雜度上的對比表。
   

### 三、 學習要點

1.  **非連續記憶體特性**：鏈結串列節點分散於記憶體中，必須透過指標追逐 (Pointer Chasing) 進行遍歷。
   
2.  **存取代價**：鏈結串列不支援索引隨機存取，存取任何元素皆需從頭開始循序掃描 (O(n))，效率較陣列 (O(1)) 低。
   
3.  **動態靈活性**：雖然在排序上效率較低，但鏈結串列具備動態調整大小的優點，且在已知節點位置時，插入與刪除的成本為 $O(1)$。


### 四、 Array v.s. Linked List 對比表格

#### 1. 時間與空間複雜度對比

| 項目 (Aspect) | 陣列 (Array) | 鏈結串列 (Linked List) | 說明 |
| :--- | :--- | :--- | :--- |
| **元素存取 (Access)** | $O(1)$ | $O(n)$ | 陣列支援索引隨機存取，串列需循序遍歷。 |
| **尋找最小值 (Find Min)** | $O(n)$ | $O(n)$ | 皆須掃描剩餘的所有元素。 |
| **交換操作 (Swap)** | $O(1)$ | $O(1)$ | 陣列交換索引值，串列交換節點內容。 |
| **元素間跳轉 (Traversal)** | $O(1)$ | $O(n)$ | 串列需要指標導航，耗時較長。 |
| **總體時間複雜度** | $O(n^2)$ | $O(n^2)$ | 兩者皆含嵌套迴圈，但串列常數項開銷較大。 |
| **空間複雜度 (Space)** | $O(1)$ | $O(1)$ | 只要僅交換數值而非重建節點，皆為原地排序。 |
| **實作開銷 (Overhead)** | 低 (Low) | 中等 (Moderate) | 串列需處理指標運算與 NULL 檢查。 |

#### 2. 資料結構特性對比

| 項目 (Aspect) | 陣列 (Array) | 鏈結串列 (Linked List) |
| :--- | :--- | :--- |
| **儲存空間 (Storage)** | 連續記憶體 (Contiguous) | 非連續記憶體 (Non-contiguous) |
| **存取方式 (Access)** | 透過索引直接存取 | 循序存取 (Sequential) |
| **額外變數 (Variables)** | **(5) 使用 `i, j, min_idx, MAX_SIZE`** | **(6) 使用 `head, current, next, min_node`** |
| **遍歷方式 (Traversal)** | 簡單的索引迭代 (Index iteration) | 指標追逐 (Pointer chasing)，速度較慢 |
| **記憶體開銷 (Overhead)** | 最小記憶體開銷 | **(10) 較高 (需額外儲存指標與動態分配)** |
| **視覺化 (Visualization)** | 容易 (方框索引表示) | 較難 (需繪製箭頭與節點連結) |
| **交換方式 (Swaps)** | 透過索引交換元素值 | **(14) 交換節點內容值 (或重新連結指標)** |
| **彈性 (Flexibility)** | 固定大小 (Fixed size) | 動態大小 (Dynamic size) |
| **總結 (Overall)** | **(17) 適合固定大小且頻繁存取的情境** | **(18) 適合動態資料且頻繁更新的情境** |

> **表格重點備註：**
> * **(5)(6)** 陣列僅需數值索引標記，而鏈結串列則必須依賴多個指標來追蹤節點位置。
> * **(10)** 鏈結串列每個節點都要多花 4 或 8 bytes 存儲指標，且動態記憶體管理會增加負擔。
> * **(14)** 在本作業中我們選擇交換值，實務上也可以透過「重新連結指標」來完成交換。
> * **(17)(18)** 陣列追求存取速度，鏈結串列追求結構調整的靈活性。

---
範圍:[Array](01_Array.pdf), [Linked List](02_LinkedList.pdf)
