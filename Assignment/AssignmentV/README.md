# Assignment V 學習歷程紀錄 : 樹狀結構之家族層級、建置與應用 (Tree Variants & Applications)


### 一、 作業目的與說明

- 本次作業的核心目標是建立對**樹狀結構 (Tree)** 家族的完整觀念，從最基礎的「一般樹」出發，逐步加入特定的結構或數值約束（如子節點數量、平衡規則、大小順序等），演化出各種具有特殊效能優勢的樹種。

- 強調將 **AI 助手（如 Gemini, ChatGPT）** 作為學習伴侶，輔助釐清定義、比較演算法效能並組織報告架構，最終由我親自消化並實作 20 個給定整數的建置過程，確保理解資料結構特性與實際應用之間的關聯。


### 二、 實作內容

針對給定的 20 個整數 `37, 142, 5, 89, 63, 117, 24, 176, 58, 133, 92, 11, 151, 72, 39, 184, 7, 101, 54, 160`，完成以下任務：

#### 1. 核心定義撰寫 (Definitions)

* **一般樹 ($General$ $Tree$)**：最基礎的非線性階層結構，每個節點可以有任意數量的子節點，且無排序規則。
  
* **二元樹 ($Binary$ $Tree$)**：每個節點最多只能有兩個子節點，嚴格區分為左右子節點。
  
* **完全二元樹 ($Complete$ $Binary$ $Tree$)**：除最後一層外各層節點數皆達最大值，且最後一層節點連續集中在最左邊。
  
* **二元搜尋樹 ($BST$)**：滿足左子樹值 < 根節點值 < 右子樹值的排序特性。
  
* **AVL 樹**：一種自我平衡的 $BST$，要求任何節點的左右子樹高度差絕對值 $\le 1$。
  
* **紅黑樹 ($Red$- $Black$ $Tree$)**：透過節點顏色規則（根黑色、無連續紅節點等）維持大致平衡的 $BST$。
  
* **最大/最小堆積 ($Max/Min$ $Heap$)**：符合堆積屬性的完全二元樹，根節點永遠是最大或最小值。

#### 2. 演化路徑分析 (Hierarchy & Transformations)

* **一般樹 $\rightarrow$ 二元樹**：限制每個節點最多只能有 2 個子節點。
  
* **二元樹 $\rightarrow$ 完全二元樹**：加入結構形狀限制，必須由上至下、由左至右填滿。
  
* **完全二元樹 $\rightarrow$ 堆積 ($Heap$)**：加入父子節點的大小順序限制。
  
* **二元樹 $\rightarrow$ $BST$**：加入數值大小順序限制。
  
* **$BST$ $\rightarrow$ AVL / 紅黑樹**：加入平衡因子或著色規則以維持平衡，防止樹高度傾斜。

#### 3. 視覺化建置 (Constructions)

我利用 **USF CAES** 與 **Tree Visualizer** 等線上工具，依序插入數據並記錄建置邏輯：

* **$BST$**：樹的形狀完全取決於輸入順序，未進行平衡演算法。
  
* **AVL 樹**：每次插入後檢查平衡因子，必要時自動執行「旋轉」以維持平衡。
  
* **堆積 ($Heap$)**：確保符合完全二元樹結構，並透過向上交換 ($Sift$-$up$) 修正父子關係。


### 三、 學習要點

1.  **平衡策略的效能取捨 ($Trade$-$offs$)**：

    * **搜尋優先 (Mostly Search)**：應選擇 **AVL 樹**。因為其嚴格的平衡策略保證了最短的平均查詢路徑，在讀多寫少的場景效率最高。
      
    * **頻繁更動 (Frequent Updates)**：應選擇 **紅黑樹**。其平衡條件較寬鬆，插入或刪除時觸發旋轉的頻率較低，能提供更佳的綜合寫入效能。
      
2.  **靜態資料的最佳實踐**：
   
    * 若資料為靜態搜尋且不需更新，我會傾向選擇 **排序陣列 ($Sorted$ $Array$) 搭配二分搜尋法**。
      
    * 原因在於陣列配置連續，具備極佳的快取局部性 ($Cache$ $Locality$)，且無需負擔樹狀結構指標 ($Pointers$) 的額外記憶體開銷。
      
3.  **AI 工具的協作思維**：
   
    * 本次作業實踐了「提問 $\rightarrow$ 釐清 $\rightarrow$ 重寫」的 AI 學習邏輯。
      
    * 利用 AI 比較複雜概念（如 AVL 與紅黑樹的平衡細節），能顯著加速學習曲線，但最後必須透過自己的理解完成報告。


### 四、 應用範例總結

| 樹狀類型 | 應用範例 | 為何適合 (關鍵屬性) |
| :--- | :--- | :--- |
| **二元樹** | 哈夫曼編碼 ($Huffman$ $Coding$) | 二進位路徑（左 0 右 1）非常適合變動長度的檔案壓縮解碼。 |
| **完全二元樹** | 區塊定址 / 陣列實作 | 結構緊湊無空隙，可映射至連續陣列儲存，節省指標空間開銷。 |
| **$BST$** | 動態字典或符號表 | 平均可在 $O(\log n)$ 時間內完成搜尋與增刪，效率優於線性結構 。 |
| **AVL 樹** | 讀取頻繁的資料庫索引 | 嚴格維持最低高度，確保查詢速度達到極致 [cite: 1281]。 |
| **紅黑樹** | C++ STL $std::map$ / $set$ | 平衡規則較彈性，在搜尋與頻繁寫入之間取得最佳平衡 。 |
| **最大堆積** | OS 行程排程 ($Scheduling$) | 根節點永遠是最高優先權，可在 $O(1)$ 取得、 $O(\log n)$ 移除。 |
| **最小堆積** | Dijkstra 最短路徑演算法 | 能最有效率地取得當前未訪問節點中的最短距離節點。 |

---
範圍:[Tree](06_Tree.pdf),[Heap](07_Heap.pdf)
