# Assignment II : Array Selection Sort

## 一、 作業目的與說明

- 本次作業的核心目標是實作並視覺化**選擇排序法（Selection Sort）**。
- 透過手寫運算流程，學習如何將抽象的演算法邏輯應用在具體的陣列資料結構上。


## 二、 實作內容

在本次作業中，我針對一組整數數列 `22, 90, 95, 100, 71, 19, 5, 70` 執行了以下任務：

### 1. 陣列結構視覺化與資料填入
- 建立了一個長度為 8 的陣列空間，並標註正確的索引（Index 0-7）。
- 將初始數列填入對應位置，建立起演算法操作的基礎資料狀態。

### 2. 選擇排序法步驟追蹤 (First 3 Steps)
詳細記錄了前三次迭代的完整變化：
- **Step 1 (i=0)**：在索引 0 到 7 之間尋找最小值（值為 5，位於索引 6），並將其與索引 0 的元素（22）交換。
- **Step 2 (i=1)**：在索引 1 到 7 之間尋找剩餘部分的最小值（值為 19，位於索引 5），並與索引 1 的元素（90）交換。
- **Step 3 (i=2)**：在索引 2 到 7 之間尋找最小值（值為 22，位於索引 6），並與索引 2 的元素（95）交換。

### 3. 演算法特性分析
- 確認了選擇排序法在各種情況下（最好、平均、最壞）的時間複雜度均為 $O(n^2)$。
- 理解其空間複雜度為 O(1)，屬於原地（In-place）排序演算法。


## 三、 學習要點

- **陣列的隨機存取優勢**：
  陣列提供 O(1) 的隨機存取能力，這使得選擇排序法能快速讀取特定索引的值來進行比較。
- **選擇排序的核心邏輯**：
  演算法將陣列分為「已排序」與「未排序」兩個部分。每一輪都會從未排序的部分找出最小元素，並將其交換至已排序部分的末尾。
- **原地排序（In-place）的概念**：
  學習到演算法不需要額外的存取空間來儲存數列，僅透過索引交換（Swap）就能完成排序。
- **效能考量**：
  理解到陣列在中間進行插入或刪除操作時成本較高（O(n)），但在排序過程中透過索引交換則非常有效率*。


## 四、 選擇排序實作流程指南

### Step 1：建立基礎陣列
1. 劃分儲存空間並標記 **Index 0** 到 **7**。
2. 填入原始數列資料。

### Step 2：執行搜尋與交換（核心迴圈）
1. 設定當前起始位置 i（從 0 開始）。
2. **尋找最小值**：從位置 i 往後掃描到最後一個元素，記錄最小值的索引 $[min\_idx]$ 。
3. **執行交換**：若找到比當前 i 更小的元素，則將 $A[i]$ 與 $A[min\_idx]$ 的值互換。

### Step 3：紀錄與驗證
1. 每一輪交換後，寫下新的陣列狀態。
2. 標註哪些部分已完成排序（即當前 i 及其之前的元素) 。
3. 重複執行直到完成排序所需的步驟。

### 補充：陣列操作效能筆記
- **隨機存取（Random Access）**：O(1)。
- **插入/刪除（Insertion/Deletion）**：O(n)，因需要移動元素。
- **本作業排序時間複雜度**：恆定為 $O(n^2)$。
