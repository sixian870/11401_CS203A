# Quiz I : C 語言動態記憶體與時間複雜度分析

範圍 : [Array](01_Array.pdf)

---

### 一、 學習要點

#### 1. 動態記憶體的核心操作

* **`malloc`**：依位元組數 (Bytes) 在堆疊區配置連續空間。
  
* **`realloc`**：動態調整已存在記憶體的大小。
  
* **`free`**：將記憶體歸還給系統，避免程序佔用過多資源。

#### 2. 指標安全準則 (Pointer Safety Guidelines)

* **分配必檢查**：呼叫 `malloc` 或 `realloc` 後，務必檢查傳回值是否為 `NULL`。若為 `NULL` 代表記憶體配置失敗，應停止操作。
  
* **釋放必歸零**：執行 `free` 釋放指標後，應立即將該指標設為 `NULL`。這能有效防止「懸空指標 (Dangling Pointer)」的產生，避免程式誤用已釋放的記憶體位址。
  
* **暫存保護機制**：使用 `realloc` 時，應使用暫存指標 (Temporary Pointer) 接收結果。直接賦值給原指標（如 `array = realloc(array, ...)`）一旦失敗會導致原地址遺失，造成 Memory Leak。
   
3.  **Big O 時間複雜度分析**：練習評估程式碼在不同運算邏輯（如存取、搜尋、排序）下的執行成本。
   
     > **1. 特性比較表 (Technical Summary)**
     > 運算類型 | 時間複雜度 | 備註 |
     > | :--- | :--- | :--- |
     > | **陣列索引存取** | $O(1)$ | 直接跳轉位址 |
     > | **未排序陣列尋找極值** | $O(n)$ | 必須逐一掃描 |
     > | **氣泡排序法 (Bubble Sort)** | $O(n^2)$ | 巢狀迴圈兩層掃描 |
     > | **n 次二分搜尋** | $O(n \log n)$ | 典型分治與迭代結合 |
     >
     > **2. Big O 成長速率順序**：
     > $O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(n!)$


### 二、 錯誤訂正

針對本次小考失分點進行深度解析與訂正：

#### 1. Q2：記憶體管理程式碼審核 (Memory Management Review)

* **原始作答**：僅提到「沒有釋放記憶體」。
  
* **錯誤訂正與分析**：
  
    * **遺漏錯誤檢查**：程式碼未檢查 `malloc()` 是否傳回 `NULL`。若分配失敗仍存取該指標，會導致系統崩潰。
      
    * **不安全的 `realloc` 用法**：直接將 `realloc` 的結果賦值給原指標（`array = realloc(...)`）是不專業的做法。一旦 `realloc` 失敗返回 `NULL`，原先持有的記憶體位址就會遺失，導致記憶體洩漏。
      
* **正確解決方案**：
  
    * 必須檢查分配是否成功。
      
    * 使用 `temp` 暫存指標。確認 `temp != NULL` 後，再將其賦值給原指標 `array`。

#### 2. Q3-1：複合運算的時間複雜度

* **原始作答**：$O(\log n)$ 。
  
* **錯誤訂正與分析**：
    * 題目要求分析在一個執行 $n$ 次的 `for` 迴圈中，重複執行二分搜尋法（Binary Search）的總複雜度。
    * 二分搜尋本身是 $O(\log n)$，但因為外層迴圈執行了 $n$ 次，根據相乘規則，總體複雜度應為 **$O(n \log n)$**。
