# Quiz IV : 圖形遍歷與樹狀結構分類

範圍 : [Tree](06_Tree.pdf),[Heap](07_Heap.pdf),[Graph](08_Graph.pdf),

### 一、 學習要點

#### 1. 圖形廣度優先搜尋 (BFS) 的深度解析

* **運作機制與資料結構**：BFS 是一種層級走訪演算法，類似於樹的 Level-order traversal。實作上必須使用 **佇列 (Queue)** 來維持「先進先出 (FIFO)」的順序，確保節點按距離（Level 1, Level 2...）依序被訪問。
  
* **與樹狀遍歷的差異**：由於圖形（Graph）可能存在環路（Cycles），為了避免陷入無窮迴圈，必須額外維護一個 **已訪問 (Visited)** 陣列來標記節點狀態。
  
* **實作心得**：在 Q1 的走訪中，我理解到 BFS 的路徑並非唯一，取決於鄰居節點進入 Queue 的順序。正確使用 Visited set 是保證圖形演算法正確性的物理邊界。

#### 2. 表達式樹的操作與數學轉化

* **中序走訪 (Inorder Traversal)**：遵循「左子樹 $\rightarrow$ 根節點 $\rightarrow$ 右子樹」的邏輯遞迴執行。
  
* **表達式還原**：在表達式樹中，葉子節點代表運算元（Operands），內部節點則代表運算子（Operators）。透過中序走訪，我能將樹狀結構轉化為標準數學算式：
  
    * **運算式**：$((3 \times 4) + (10 / 2)) - 3$ 。
      
    * **計算結果**：依據運算順序得出最終結果為 **14**。
      
這讓我體會到資料結構如何承載邏輯運算，中序走訪是連結「機器樹狀邏輯」與「人類算式習慣」的關鍵橋樑。

#### 3. 二元樹的分類

根據限制條件的不同，二元樹可精確劃分為兩大類別：

* **基於形狀 (Shape-based)**：側重於結構上的幾何與填充約束。
  
    * **代表：完全二元樹 (Complete Binary Tree)**：除了最後一層外，每一層都必須填滿，且最後一層節點須由左至右連續排列。這種結構不產生記憶體空洞，因此是實作 **堆積 (Heap)** 的理想基礎。
      
* **基於規則 (Criteria-based)**：側重於節點間的數值排序或平衡規則。
  
    * **二元搜尋樹 (BST)**：左子樹 < 根 < 右子樹，旨在優化搜尋效率。
      
    * **AVL / 紅黑樹**：在 BST 基礎上增加平衡規則（如平衡因子或著色規則），確保最壞情況下的操作高度維持在 $O(\log n)$。
      
    * **堆積 (Heap)**：父節點與子節點間具備固定的大小關係（Max/Min Property），常用於優先權佇列。

> 總結

> | 類別 | 關鍵術語 | 時間複雜度/特性 | 核心價值 |
> | :--- | :--- | :--- | :--- |
> | **圖形走訪** | BFS | $O(V+E)$ / 使用 Queue | 尋找最短路徑（無加權） |
> | **樹狀走訪** | Inorder | $O(n)$ / Left-Root-Right | 產生中序算式 |
> | **結構約束** | Complete BT | 緊湊存儲 | 適合用陣列 (Array) 實作 |
> | **數值規則** | BST / AVL | 平均 $O(\log n)$ | 提升動態資料搜尋效率 |
